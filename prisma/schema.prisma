// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id           String          @id @default(uuid()) @db.Uuid
  email        String          @unique
  username     String?         @unique
  displayName  String?
  passwordHash String
  avatar       String?
  googleId     String?         @unique // For Google OAuth
  bio          String?
  location     String? // e.g. "Lagos, Nigeria"
  website      String?
  socialLinks  Json? // { twitter, instagram, linkedin, facebook }
  isVerified   Boolean         @default(false)
  roles        UserRole[]
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  lastLoginAt  DateTime?
  deletedAt    DateTime? // Soft delete for account deletion
  interests    EventCategory[]

  resetPasswordToken   String?   @unique
  resetPasswordExpires DateTime?

  // Relations
  events          Event[]
  reviews         Review[]
  followers       Follow[]          @relation("following")
  following       Follow[]          @relation("followers")
  favorites       Favorite[]
  tickets         UserTicket[]
  settings        UserSettings?
  orders          BookingOrder[]
  teamMemberships EventTeamMember[]
  chatMessages    ChatMessage[]
  chatMemberships ChatMember[]
}

enum UserRole {
  organizer
  vendor
  attendee
  dual
}

enum EventCategory {
  MUSIC
  TECH
  BUSINESS
  ARTS
  SPORTS
  EDUCATION
  ENTERTAINMENT
  COMMUNITY
  WELLNESS
  FOOD_DRINK
  OTHER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
  RESCHEDULED
}

enum EventPrivacy {
  PUBLIC
  PRIVATE
  UNLISTED
}

enum TicketType {
  FREE
  PAID
  DONATION
}

enum TeamRole {
  ORGANIZER
  CO_HOST
  MANAGER
  ASSISTANT
}

enum TeamMemberStatus {
  ACTIVE
  PENDING
}

model Event {
  id               String        @id @default(uuid()) @db.Uuid
  title            String
  description      String
  shortDescription String?
  category         EventCategory
  tags             String[]

  status  EventStatus  @default(DRAFT)
  privacy EventPrivacy @default(PUBLIC)

  // Location
  locationType   String // PHYSICAL, ONLINE, HYBRID
  address        String?
  venueName      String?
  city           String?
  state          String?
  country        String?
  postalCode     String?
  lat            Float?
  lng            Float?
  onlineUrl      String?
  onlinePassword String?

  // Schedule
  startDate DateTime
  endDate   DateTime
  startTime String
  endTime   String
  timezone  String

  // Media
  coverImage String
  gallery    String[]
  videoUrl   String?

  organizerId String @db.Uuid
  organizer   User   @relation(fields: [organizerId], references: [id])

  tickets       Ticket[]
  reviews       Review[]
  scheduleItems ScheduleItem[]
  favorites     Favorite[]
  userTickets   UserTicket[]
  orders        BookingOrder[]
  teamMembers   EventTeamMember[]
  chat          EventChat?

  // Metadata
  isFeatured     Boolean  @default(false)
  attendeesCount Int      @default(0)
  favoritesCount Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Ticket {
  id          String     @id @default(uuid()) @db.Uuid
  name        String
  description String?
  type        TicketType
  price       Float
  currency    String
  quantity    Int
  remaining   Int
  maxPerUser  Int?
  salesStart  DateTime?
  salesEnd    DateTime?

  eventId     String       @db.Uuid
  event       Event        @relation(fields: [eventId], references: [id])
  userTickets UserTicket[]
  orderItems  OrderItem[]
  attendees   Attendee[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Review {
  id           String   @id @default(uuid()) @db.Uuid
  rating       Int // 1-5
  title        String?
  comment      String
  photos       String[]
  helpfulCount Int      @default(0)

  eventId String @db.Uuid
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ScheduleItem {
  id          String  @id @default(uuid()) @db.Uuid
  time        String // e.g. "10:00 AM"
  activity    String
  description String?
  order       Int     @default(0)

  eventId String @db.Uuid
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model Follow {
  id          String   @id @default(uuid()) @db.Uuid
  followerId  String   @db.Uuid
  follower    User     @relation("followers", fields: [followerId], references: [id])
  followingId String   @db.Uuid
  following   User     @relation("following", fields: [followingId], references: [id])
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
}

model Favorite {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id])
  createdAt DateTime @default(now())

  @@unique([userId, eventId])
}

model UserTicket {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  user         User     @relation(fields: [userId], references: [id])
  ticketId     String   @db.Uuid
  ticket       Ticket   @relation(fields: [ticketId], references: [id])
  eventId      String   @db.Uuid
  event        Event    @relation(fields: [eventId], references: [id])
  quantity     Int      @default(1)
  status       String   @default("valid") // valid, used, cancelled, expired
  qrCode       String?
  purchaseDate DateTime @default(now())
}

model UserSettings {
  id            String   @id @default(uuid()) @db.Uuid
  userId        String   @unique @db.Uuid
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifications Json     @default("{\"email\":true,\"push\":true,\"sms\":false,\"eventReminders\":true,\"eventNearby\":true,\"eventUpdates\":true,\"ticketSales\":true,\"bookingRequests\":true,\"bookingConfirmations\":true,\"reviews\":true,\"newMessages\":true,\"paymentNotifications\":true,\"marketing\":false,\"locationBased\":true}")
  privacy       Json     @default("{\"profileVisibility\":\"public\",\"showEmail\":false,\"showPhone\":false,\"allowMessages\":true}")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// ============ BOOKING SYSTEM ============

enum OrderStatus {
  PENDING
  CONFIRMED
  CANCELLED
  REFUNDED
  EXPIRED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

model BookingOrder {
  id      String @id @default(uuid()) @db.Uuid
  userId  String @db.Uuid
  user    User   @relation(fields: [userId], references: [id])
  eventId String @db.Uuid
  event   Event  @relation(fields: [eventId], references: [id])

  items     OrderItem[]
  attendees Attendee[]

  // Pricing
  subtotal   Float
  serviceFee Float  @default(0)
  discount   Float  @default(0)
  total      Float
  currency   String @default("NGN")

  // Status
  status           OrderStatus   @default(PENDING)
  paymentStatus    PaymentStatus @default(PENDING)
  paymentMethod    String? // card, bank_transfer, mobile_money, free
  paymentReference String?

  // Promo
  promoCode String?

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  expiresAt   DateTime? // Order expires if not paid
  paidAt      DateTime?
  confirmedAt DateTime?
}

model OrderItem {
  id         String       @id @default(uuid()) @db.Uuid
  orderId    String       @db.Uuid
  order      BookingOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  ticketId   String       @db.Uuid
  ticket     Ticket       @relation(fields: [ticketId], references: [id])
  ticketName String
  quantity   Int
  unitPrice  Float
  totalPrice Float
}

model Attendee {
  id            String       @id @default(uuid()) @db.Uuid
  orderId       String       @db.Uuid
  order         BookingOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  ticketId      String       @db.Uuid
  ticket        Ticket       @relation(fields: [ticketId], references: [id])
  name          String
  email         String
  phone         String?
  ticketCode    String       @unique // Unique QR code content
  checkedIn     Boolean      @default(false)
  checkedInAt   DateTime?
  checkInMethod String? // 'manual' | 'qr_scan'
  status        String       @default("valid") // valid, used, cancelled, expired
  createdAt     DateTime     @default(now())
}

model EventTeamMember {
  id          String           @id @default(uuid()) @db.Uuid
  eventId     String           @db.Uuid
  event       Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId      String?          @db.Uuid // null if pending invitation
  user        User?            @relation(fields: [userId], references: [id])
  email       String // for pending invitations
  role        TeamRole
  status      TeamMemberStatus @default(PENDING)
  inviteToken String? // for pending invitations
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([eventId, userId])
  @@unique([eventId, email])
}

// ==================== CHAT ====================

enum MessageType {
  TEXT
  IMAGE
  ANNOUNCEMENT
  SYSTEM
}

enum ChatRole {
  MEMBER
  MODERATOR
  ORGANIZER
}

model EventChat {
  id       String  @id @default(uuid()) @db.Uuid
  eventId  String  @unique @db.Uuid
  event    Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  isActive Boolean @default(true)

  // Settings
  slowMode    Int     @default(0) // seconds between messages, 0 = disabled
  membersOnly Boolean @default(true) // only ticket holders can send

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages ChatMessage[]
  members  ChatMember[]
}

model ChatMessage {
  id       String    @id @default(uuid()) @db.Uuid
  chatId   String    @db.Uuid
  chat     EventChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  senderId String    @db.Uuid
  sender   User      @relation(fields: [senderId], references: [id])

  content String
  type    MessageType @default(TEXT)

  replyToId String?       @db.Uuid
  replyTo   ChatMessage?  @relation("Replies", fields: [replyToId], references: [id])
  replies   ChatMessage[] @relation("Replies")

  isPinned  Boolean @default(false)
  isDeleted Boolean @default(false)
  deletedBy String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChatMember {
  id     String    @id @default(uuid()) @db.Uuid
  chatId String    @db.Uuid
  chat   EventChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  userId String    @db.Uuid
  user   User      @relation(fields: [userId], references: [id])

  role       ChatRole  @default(MEMBER)
  isMuted    Boolean   @default(false)
  mutedUntil DateTime?

  joinedAt   DateTime @default(now())
  lastSeenAt DateTime @default(now())

  @@unique([chatId, userId])
}
